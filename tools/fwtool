#!/usr/bin/perl

use strict;
use warnings;
use IO::File;
use Getopt::Long;
use File::Basename;
use lib dirname (__FILE__);
use Firmware::Silead;

sub usage() {
	print STDERR "Usage: fwtool [MODE] [INPUT] [MODIFIERS] [OUTPUT]\n";
	print STDERR "[MODE] is one of:\n";
	print STDERR "-r                (Read-only mode, default) Prints statistics and/or information about firmware\n";
	print STDERR "-w                (Read-write mode) Writes a new firmware image, optionally setting flags\n";
	print STDERR "[INPUT] specifies the input:\n";
	print STDERR "-f [FORMAT]       (Optional, default: auto) Sets the input file format\n";
	print STDERR "-i [FILE]         Specifies the input firmware file\n";
	print STDERR "[MODIFIERS] can be any number of:\n";
	print STDERR "-s [KEY]=[VALUE]  Sets flag KEY to VALUE\n";
	print STDERR "[OUTPUT] specifies the output:\n";
	print STDERR "-g [FORMAT]       (Optional, default: copy) Sets the output file format\n";
	print STDERR "-o [FILE]         (Optional, input will be overwritten if omitted) Specifies the output firmware file\n";
	print STDERR "[FORMAT] is one of:\n";
	print STDERR "auto              (Only valid for input) Auto-detect firmware\n";
	print STDERR "copy              (Only valid for output) Use the same format as input\n";
	print STDERR "old               Old-style binary firmware, as used by the Android driver\n";
	print STDERR "new               New-style binary firmware, as used by gslx680-acpi\n";
	print STDERR "header            C header file containing a firmware image and calibration data\n";
	print STDERR "win               Scrambled firmware, as used by the Windows driver\n";
	print STDERR "[KEY] can be:\n";
	print STDERR "model             A 4-character string describing the controller (ex.: 1680, default=    )\n";
	print STDERR "width             The width of the touch panel, i.e. x coordinate maximum (0-4095, default=4095)\n";
	print STDERR "height            The height of the touch panel, i.e. the y coordinate maximum (0-4095, default=4095)\n";
	print STDERR "points            The number of supported touch points (1-10, default=10)\n";
	print STDERR "track             Enables in-kernel finger tracking (1=enable, 0=disable, default=enable)\n";
	print STDERR "xflip             Enables horizontal flipping (1=enable, 0=disable, default=disable)\n";
	print STDERR "yflip             Enables vertical flipping (1=enable, 0=disable, default=disable)\n";
	print STDERR "swap              Enables x-y axis swapping (1=enable, 0=disable, default=disable)\n";
	-1;
}

my ($readwrite, $iformat, $ifile, $oformat, $ofile) = (0, 'auto', undef, 'copy', undef);
my %flags;
GetOptions(
	'read' => sub { $readwrite = 0; },
	'write' => sub { $readwrite = 1; },
	'f|iformat=s' => \$iformat,
	'ifile=s' => \$ifile,
	'g|oformat=s' => \$oformat,
	'ofile=s' => \$ofile,
	'set=s%' => $flags,
) or exit usage;

defined $ifile or exit usage;

print "Loading $ifile...\n";
my $rep = Firmware::Silead->load_as($ifile, $iformat);
if (!defined($rep)) {
	if ($iformat eq 'auto') {
		die "Can't autodetect format of $ifile - is this really a firmware image?";
	} else {
		die "Invalid input - can't load $ifile as type $iformat (or $iformat is not a valid format)";
	}
}

if (!$readwrite) {
	print "Controller model: " . $rep->model . "\n";
	print "Panel width: " . $rep->width . "\n";
	print "Panel height: " . $rep->height . "\n";
	print "Number of touch points: " . $rep->touches . "\n";
	print "X axis flipped: " . ($rep->xmirrored ? "yes" : "no") . "\n";
	print "Y axis flipped: " . ($rep->ymirrored ? "yes" : "no") . "\n";
	print "X and Y axes swapped: " . ($rep->swapped ? "yes" : "no") . "\n";
	print "Software tracking enabled: " . ($rep->tracking ? "yes" : "no") . "\n";
	my @pages = $rep->get_pages;
	print "Number of pages: ". scalar(@pages) . "\n";
	print "Page list:";
	for my $page (@pages) {
		printf " %02x", $page;
	}
	print "\n";
}

if ($readwrite) {
	print "Setting parameters...\n" unless !int %flags;
	for my $key (keys(%flags)) {
		$rep->set_param($key, $flags{$key});
	}

	if ($oformat eq 'copy') {
		# TODO does not work for auto, implement better detection api
		$oformat = $iformat;
	}
	print "Saving $ofile...\n";
	if (!$rep->save_as($ofile, $oformat)) {
		die "Error saving to $ofile";
	}
}

do {
	my $in = IO::File->new($tscfg, 'r') or die "Can't open $tscfg: $!";
	$in->binmode;
	local $/ = undef;
	$data = <$in>;
	defined($data) or die "Can't load firmware: $!";
	$in->close();
};
